#define DIV_17_16(N) ((_hi( _mpyid(((N) + 1), 0xF0F0F0F))) >> 4)

#include "math_big.h"

static uint128_t tmp128;
static uword64_t tmp64;
uint128_t init128(){
   quint8 i = 0;
   for (i = 0; i < 4; i++){
       tmp128.word32[i] = 0;
   }
   return tmp128;
}
uword64_t init64(){
   quint8 i = 0;
   for (i = 0; i < 2; i++){
       tmp64.word32[i] = 0;
   }
   return tmp64;
}
/*******************************************************************************
 *    Функция сложения 2-ух 128-битных чисел (item1 и item2), заданных в 
 * формате структуры uint128_T. Результат вычисления 128-битное число, 
 * возвращаемое в параметре result. 
 *    Сложение производится "столбиком". Промежуточная разрядность 
 * вычислений 2^16.
 *    Указатель на result может совпадать с одним из слогаемых.
 *    Если result не совпадает с item1, item2, то содержимое item1 и item2 не 
 * изменяется.
 ******************************************************************************/
void add_128(const uint128_t *item1, const uint128_t *item2, uint128_t *result){
    quint8 i = 0;
    word32_t temp;

    uint128_t sum=init128();

    temp.word32 = 0;   // обнуление вспомогательной переменной  

    for (i = 0; i < 8; i++){
        temp.word32 += item1->word16[i];  // сложение очередных разрядов item1, 
        temp.word32 += item2->word16[i];  // item2 и переноса
        sum.word16[i] = temp.word16[0];   // сохранение результата во временной 
                                          // переменной
        temp.word16[0] = temp.word16[1];  // арифметический 
        temp.word16[1] = 0;               // сдвиг на 16 разрядов
    }

    *result = sum;  // вывод результата
    return;
}

/*******************************************************************************
 *
 ******************************************************************************/
void addc_128(const uint128_t *item1, const quint32 item2, uint128_t *result){
    uint128_t temp;
    temp.word32[3] = 0;
    temp.word32[2] = 0;
    temp.word32[1] = 0;
    temp.word32[0] = item2; 
    add_128(item1, &temp, result);
    return;
}

/*******************************************************************************
 *
 ******************************************************************************/
void subc_128(const uint128_t *item1, const quint32 item2, uint128_t *result){
    uint128_t temp;
    temp.word32[3] = 0;
    temp.word32[2] = 0;
    temp.word32[1] = 0;
    temp.word32[0] = item2; 
    sub_128(item1, &temp, result);
    return;
}

/*******************************************************************************
 * Функция изменения знака 128-разрядного числа
 ******************************************************************************/
void neg_128(const uint128_t *item1, uint128_t *result){
    uint128_t temp;
    temp.word32[3] = 0;
    temp.word32[2] = 0;
    temp.word32[1] = 0;
    temp.word32[0] = 0; 
    sub_128(&temp, item1, result);
    return;
}

/*******************************************************************************
 *   Функция сложения 2-ух 64-битных чисел (item1 и item2), результат - 64 - 
 * битное число. Аналог add_128().
 ******************************************************************************/
void add_64(const uword64_t *item1, const uword64_t *item2, uword64_t *result){
    quint8 i = 0;
    word32_t temp;
    uword64_t sum = init64();

    temp.word32 = 0;   // обнуление вспомогательной переменной 

    for (i = 0; i < 4; i++){
        temp.word32 += item1->word16[i];  // сложение очередных разрядов item1, 
        temp.word32 += item2->word16[i];  // item2 и переноса
        sum.word16[i] = temp.word16[0];   // сохранение результата во временной 
                                          // переменной
        temp.word16[0] = temp.word16[1];  // арифметический 
        temp.word16[1] = 0;               // сдвиг на 16 разрядов
    }

    *result = sum;  // вывод результата 
    return;
}

/*******************************************************************************
 *    Функция вычитания 128-битных чисел (item1 и item2), заданных в формате 
 * структуры uint128_t. Результат вычисления 128-битное число, возвращаемое
 * в параметре result. 
 *    Сложение производится "столбиком". Промежуточная разрядность 
 * вычислений 2^16.
 *    Указатель на result может совпадать с одним из слогаемых.
 *    Если result не совпадает с item1, item2, то содержимое item1 и item2 не 
 * изменяется.
 ******************************************************************************/
void sub_128(const uint128_t *item1, const uint128_t *item2, uint128_t *result){
    quint8 i = 0;
    word32_t temp;
    uint128_t rem=init128();

    temp.word32 = 0;   // обнуление вспомогательной переменной 

    for (i = 0; i < 8; i++){
        temp.word32 += item1->word16[i];  // вычитание очередных разрядов item1, 
        temp.word32 -= item2->word16[i];  // item2 и переноса
        rem.word16[i] = temp.word16[0];   // сохранение результата во временной 
                                          // переменной
        temp.word16[0] = temp.word16[1];  // арифметический  сдвиг на 16 разрядов
    }

    *result = rem;  // запись результата вычисление 
    return;
}

/*****************************************************************************
 *   Функция вычитания 2-ух 64-битных чисел (item1 и item2), результат - 64 - 
 * битное число. 
 ****************************************************************************/
void sub_64(const uword64_t *item1, const uword64_t *item2, uword64_t *result){
    quint8 i = 0;
    word32_t temp;
    uword64_t rem=init64();

    temp.word32 = 0;   //  обнуление вспомогательной переменной 

    for (i = 0; i < 4; i++){
        temp.word32 += item1->word16[i];  // вычитание очередных разрядов item1, 
        temp.word32 -= item2->word16[i];  // item2 и переноса
        rem.word16[i] = temp.word16[0];   // сохранение результата во временной 
                                          // переменной
        temp.word16[0] = temp.word16[1];  // арифметический сдвиг на 16 разрядов
    }

    *result = rem;  // вывод результата
    return;
}

/*******************************************************************************
 *    Функция умножения 2-ух 64-битных чисел (item1 и item2), результат - 
 * 128-битное число. 
 ******************************************************************************/
void mult(const uword64_t *factor1, const uword64_t *factor2, uint128_t *result){
    uint128_t product;
    uint128_t row;          // временные переменные
    word32_t vword;         //
    quint8 n,k;            // переменные цикла

    product.word32[0] = 0; // обнуление временных переменных
    product.word32[1] = 0; //
    product.word32[2] = 0; //
    product.word32[3] = 0; //

    for (n = 0; n < 4; n++){ // умножение столбиком 
        row.word32[0] = 0;   // 
        row.word32[1] = 0;   // обнуление временной переменной  
        row.word32[2] = 0;   //
        row.word32[3] = 0;   //
        vword.word32 = 0;  
        for (k = 0; k < 4; k++) { // вычисление "строки"
            vword.word32 += factor1->word16[n] * factor2->word16[k]; 
            row.word16[n + k] = vword.word16[0]; // сохранение результата
            vword.word16[0] = vword.word16[1];   // сдвиг разрядов
            vword.word16[1] = 0;
        }
        row.word16[n+k] = vword.word16[0];   // сохранение старшего разряда
        add_128(&row, &product, &product);   // сложение строк
    }
    *result = product;  // вывод результата
    return;
}

/*******************************************************************************
 *
 ******************************************************************************/
void multc(const uword64_t *factor1, const quint32 factor2, uint128_t *result){
    uword64_t temp;
    temp.word32[1] = 0;
    temp.word32[0] = factor2;
    mult(factor1, &temp, result);
    return;
}

/*******************************************************************************
 *    Функция деления  128-битного числа (item1) на 32-битное число (item2), 
 * результат - 128-битное число(частное) и остаток от деления - 32-битное 
 * число(mod). 
 ******************************************************************************/
void div_128(const uint128_t *factor1, const quint16 factor2, 
             uint128_t *result_quot, quint16 *result_rem){

    uint128_t quot=init128(); // частное от деления
    word32_t rem;  // остаток от деления
    word32_t temp;  // вспомагательная переменная
    int n;     // сюда записывается старший значащий номер байта 

    rem.word32 = 0; // обнуление вспомагательной переменных

    for (n = 7; n >= 0; n--){
        rem.word16[1] = rem.word16[0];       // сдвиг на 16 разрядов
        rem.word16[0] = factor1->word16[n];  //
        temp.word32 = rem.word32 / factor2;  // вычисление частного
        quot.word16[n] = temp.word16[0];     //    
        rem.word32 = rem.word32 % factor2;   // вычисление промежуточного остатка
    }
    *result_quot = quot;
    *result_rem = rem.word16[0];
    return;
}

/*******************************************************************************
 * Функция инкремента 128-разрядного числа
 ******************************************************************************/
void inc_128(uint128_t *item){
    quint8 n = 0;
    for (n = 0; n < 4; n++) {
        item->word32[n]++;
        if ((item->word32[n]) != 0)
            return;
    }
    return;
}

/*******************************************************************************
 * Функция инкремента 64-разрядного числа
 ******************************************************************************/
void inc_64(uword64_t *item)
{
    item->word32[0]++;
    if (item->word32[0] == 0)
        item->word32[1]++;
}

/*******************************************************************************
 * Функция дикремента 128-разрядного числа
 ******************************************************************************/
void dec_128(uint128_t *item){
    quint8 n = 0;
    for (n = 0; n < 4; n++) {
        item->word32[n]--;
        if ((item->word32[n]) != 0xFFFFFFFF)
            return;
    }
    return;
}

/*******************************************************************************
 * Функция дикремента 64-разрядного числа
 ******************************************************************************/
void dec_64(uword64_t *item){
    item->word32[0]--;
    if (item->word32[0] == 0xFFFFFFFF)
        item->word32[1]--;
    return;
}

/*******************************************************************************
 * Функция сложения 2-ух 128-битных полиномов  (item1 и item2), результат - 
 * 128 - битное число. 
 ******************************************************************************/
void xor_128(const uint128_t *item1, const uint128_t *item2, uint128_t *result){
    result->word32[0] = item1->word32[0] ^ item2->word32[0];
    result->word32[1] = item1->word32[1] ^ item2->word32[1];
    result->word32[2] = item1->word32[2] ^ item2->word32[2];
    result->word32[3] = item1->word32[3] ^ item2->word32[3];
    return;
}
/*******************************************************************************
 * Функция сложения 2-ух 64-битных полиномов  (item1 и item2), результат - 
 * 128 - битное число. 
 ******************************************************************************/
void xor_64(const uword64_t *item1, const uword64_t *item2, uword64_t *result){
    result->word32[0] = item1->word32[0] ^ item2->word32[0];
    result->word32[1] = item1->word32[1] ^ item2->word32[1];
    return;
}

/*******************************************************************************
 * Функция умножения 2-ух 128-битных полиномов  (item1 и item2), результат - 
 * 128 - битное число. 
 ******************************************************************************/
void multp_128(const uint128_t *pol1, const uint128_t *pol2, 
               const uint128_t *generic, uint128_t *result){
    uint128_t product;
    uint128_t temp;
    quint8 n,k;

    product.word32[0] = 0;
    product.word32[1] = 0;
    product.word32[2] = 0;
    product.word32[3] = 0;
    temp = *pol1;
    for (n = 0; n < 4; n++) {
        for (k = 0; k < 32; k++) {
            if (((pol2->word32[n] >> k) & 0x01) != 0)
                xor_128(&product, &temp, &product);        
            if ((temp.word32[3] >> 31) == 0)
                shl_128(&temp,&temp, 1);
            else {
                shl_128(&temp, &temp, 1);
                xor_128(&temp, generic, &temp);        
            }
        }
    }
    *result = product;
    return;
}

/*****************************************************************************
 * Функция сдвига 128-битного полинома  (item1) на mv_pol бит, результат - 
 * 128 - битный полином. 
 ****************************************************************************/
void shl_128(const uint128_t *pol, uint128_t *result, quint8 shift){
    uint128_t shf_pol=init128();
    quint32 temp = 0;
    quint8 shf32 = 0;
    int n = 0;

    //  shf32=shift/32; // количество целых 32 разрядных слов
    //  shift%=32;      // сдвиг внутри 32 разрядов
    shf32 = (shift >> 5); // количество целых 32 разрядных слов
    shift &= 0x1F;         // сдвиг внутри 32 разрядов

    for (n = 0; n < 4; n++) {
        shf_pol.word32[n] = temp >> (32 - shift);
        if (n >= shf32)
            temp = pol->word32[n - shf32];
        shf_pol.word32[n] |= temp << shift;
    }
    *result = shf_pol;
    return;
}

/*****************************************************************************
 * Функция сдвига 128-битного полинома  (item1) на mv_pol бит, результат - 
 * 128 - битный полином. 
 ****************************************************************************/
void shr_128(const uint128_t *pol, uint128_t *result, quint8 shift){//Проверена только на сдвиге 1
    uint128_t shf_pol=init128();
    quint32 temp = 0;
    quint8 shf32 = 0;
    int n = 0;

    shf32 = (shift >> 5); // количество целых 32 разрядных слов
    shift &= 0x1F;         // сдвиг внутри 32 разрядов

    for (n = 3; n >= 0; n--) {
        shf_pol.word32[n] = temp << (32 - shift);
        if (n >= shf32)
            temp = pol->word32[n - shf32];
        shf_pol.word32[n] |= temp >> shift;
    }
    //  shf_pol.word32[n]=temp<<32-shift;
    *result = shf_pol;
    return;
}

/*******************************************************************************
 *   Функция возведения в целую степень(от 1 до 2^128-1) элемента поля GF(2^128)
 * (128-битного полинома).
 ******************************************************************************/
void powp_128(const uint128_t *pol, uint128_t *degree,
              uint128_t *generic,  uint128_t *result){
    uint128_t pol_2_n;
    uint128_t product;
    quint8 n, k;

    product.word32[3] = 0x00000000;
    product.word32[2] = 0x00000000;
    product.word32[1] = 0x00000000;
    product.word32[0] = 0x00000001;
    pol_2_n = *pol;

    for (n = 0; n < 2; n++)
        for (k = 0; k < 32; k++) {
            if (((degree->word32[n] >> k) & 0x01) != 0)
                multp_128(&product, &pol_2_n, generic, &product);
            multp_128(&pol_2_n, &pol_2_n, generic, &pol_2_n);  
    }  
    *result = product;
    return;
}
